<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tron Address Vanity Check - Suffix Repeat Counter</title>
<meta name="author" content="GitHub:https://github.com/betaer/Tron-Address-Checker/">
<style>
body {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: Arial, sans-serif;
}
#inputArea {
    width: 50%;
    padding: 20px;
}
#resultArea {
    width: 80%;
    padding: 20px;
}
table {
    width: 100%;
    border-collapse: collapse;
}
table, th, td {
    border: 1px solid black;
}
th, td {
    padding: 8px;
    text-align: left;
}
</style>
</head>
<body>
<div id="inputArea">
    <label for="fileInput">1.</label>
<input type="file" id="fileInput" accept=".csv, .txt, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
<br><br>
    <button id="calculateButton">2. Calculate</button><br>
    <button id="exportButton">3. Export Results</button>
    <br>
    <b>Instructions</b>:<br>
    This calculator is used to calculate the suffix repeat count of Tron addresses.<br>
    Supports importing .txt and .csv files. Column A contains keys, and Column B contains addresses. Only the last N characters of addresses in Column B are calculated, and the repeat count is output to Column C.<br>
    <b>Usage:</b><br>
    1. Select a .txt file generated by a Tron address generator (two columns: key, address, separated by commas).<br>
    2. Click "Calculate" to compute the repeat count of the last N characters in Column B to Column C.<br>
    3. Click "Export" to export the results as a .csv file. You can use Excel, Numbers, etc., to filter the results.
</div>
</div>
<div id="resultArea">
    <table id="resultTable">
        <thead>
            <tr>
                <th>Column A</th>
                <th>Column B</th>
                <th>Column C (Suffix Repeat Count of Column B)</th>
            </tr>
        </thead>
        <tbody>
        <!-- Calculation results will appear here -->
        </tbody>
    </table>
</div>

<script>
document.getElementById('calculateButton').addEventListener('click', function() {
    const fileInput = document.getElementById('fileInput');
    if (fileInput.files.length === 0) {
        alert('Please select a CSV or TXT file to import, then click Calculate, and finally Export.');
        return;
    }
    const file = fileInput.files[0];
    const reader = new FileReader();

    reader.onload = function(e) {
        const content = e.target.result;
        const rows = content.split('\n'); // Split content by line
        const resultTableBody = document.getElementById('resultTable').querySelector('tbody');

        // Clear table content
        resultTableBody.innerHTML = '';

        rows.forEach(row => {
            const cells = row.split(','); // Split columns by comma
            if (cells.length >= 2) {
                const aCell = cells[0].trim();
                const bCell = cells[1].trim();
                const repeatCount = calculateSuffixRepeat(bCell);

                const newRow = resultTableBody.insertRow();

                const cellA = newRow.insertCell(0);
                const cellB = newRow.insertCell(1);
                const cellC = newRow.insertCell(2);

                cellA.textContent = aCell;
                cellB.textContent = bCell;
                cellC.textContent = repeatCount;
            }
        });
    };

    reader.readAsText(file);
});

document.getElementById('exportButton').addEventListener('click', function() {
    const fileInput = document.getElementById('fileInput');
    if (fileInput.files.length === 0) {
        alert('Please select a CSV or TXT file to import, then click Calculate, and finally Export.');
        return;
    }

    const resultTable = document.getElementById('resultTable');
    const originalFileName = fileInput.files[0].name;
    const fileNameWithoutExtension = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
    const newFileName = `${fileNameWithoutExtension}-checked.txt`;

    let txtContent = "\uFEFF"; // Add BOM to ensure UTF-8 encoding

    // Get table rows
    const rows = resultTable.querySelectorAll('tr');
    rows.forEach(row => {
        const cols = row.querySelectorAll('th, td');
        const rowData = Array.from(cols).map(col => col.textContent).join(",");
        txtContent += rowData + "\n";
    });

    // Create download link
    const encodedUri = encodeURI("data:text/plain;charset=utf-8," + txtContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", newFileName); // Set dynamic file name for export
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
});

function calculateSuffixRepeat(str) {
    // Calculate the count of consecutive repeating characters from the end of the string, case-insensitive
    if (str.length === 0) return 0;

    let repeatCount = 0;
    const lowerStr = str.toLowerCase();
    const lastChar = lowerStr[lowerStr.length - 1];

    // Ensure accurate calculation of consecutive repeating characters
    for (let i = lowerStr.length - 1; i >= 0; i--) {
        if (lowerStr[i] === lastChar) {
            repeatCount++;
        } else {
            break;
        }
    }

    return repeatCount;
}
</script>
</body>
</html>